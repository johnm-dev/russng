#! /bin/bash
#
# ruservice

ETC_DIR="/etc/russ"
RUN_DIR="/var/run/russ"
CONF_DIR="${RUN_DIR}/conf"
PIDS_DIR="${RUN_DIR}/pids"
SERVICES_DIR="${RUN_DIR}/services"
SOURCES_FILE="${ETC_DIR}/ruservice.sources"

function clean_confdir {
	# using explicit path rather than variable!
	rm -rf /var/run/russ/conf/*
}

function clean_dirs {
	local confname confrdir

	confname=$1; shift 1
	confrdir=$(dirname "${confname}")

	while [ "${confrdir}" != "." ]; do
		for path in "${PIDS_DIR}/${confrdir}" "${SERVICES_DIR}/${confrdir}"; do
			if is_dir_empty "${path}"; then
				rmdir "${path}"
				if [ $? -ne 0 ]; then
					echoe "error: cannot remove directory (${path})"
				fi
			fi
		done
		confrdir=$(dirname "${confrdir}")
	done
}

function clean_servicefile {
	local confname

	confname=$1; shift 1

	rm -f "${SERVICES_DIR}/${confname}" 2> /dev/null
}

function create_dirs {
	local confname confrdir

	confname=$1; shift 1
	confrdir=$(dirname "${confname}")

	for path in "${PIDS_DIR}/${confrdir}" "${SERVICES_DIR}/${confrdir}"; do
		if [ ! -d "${path}" ]; then
			mkdir -m 0755 -p "${path}"
			if [ $? -ne 0 ]; then
				echoe "error: cannot create directory (${path})"
				exit 1
			fi
		fi
	done
}

function echoe {
	echo "$*" 1>&2
}

function get_confnames {
	local confname confnames filename filenames

	confname=$1; shift 1

	confnames=()
	if [ "${confname}" = "." ]; then
		filenames=$(cd "${CONF_DIR}"; find * 2>/dev/null | grep "\.conf")
	else
		# file
		filenames=$(cd "${CONF_DIR}"; find "${confname}.conf" 2>/dev/null | grep "\.conf" 2>/dev/null)
		if [ -z "${filenames}" ]; then
			# dir
			filenames=$(cd "${CONF_DIR}"; find "${confname}" 2>/dev/null | grep "\.conf" 2>/dev/null)
		fi
	fi
	for filename in ${filenames}; do
		confnames+=("${filename%.conf}")
	done
	echo "${confnames[*]}"
}

function get_confnamesbyname {
	local confnames filename filenames line matchname part

	matchname=$1; shift 1

	confnames=()
	filenames=$(cd "${CONF_DIR}"; find * 2>/dev/null | grep "\.conf" 2>/dev/null)
	for filename in ${filenames}; do
		line=$(head -1 "${filename}" | grep -E " name=${matchname}")
		for part in ${line}; do
			if [ "${part}" = "name=${matchname}" ]; then
				confnames+=("${filename%.conf}")
			fi
		done
	done
	echo "${confnames[*]}"
}

function get_pid {
	local confname pid pidpath

	confname=$1; shift 1

	pidpath=$(get_pidpath "${confname}")
	pid=$(cat "${pidpath}" 2> /dev/null)
	echo "${pid}"
}

function get_pidpath {
	local confname

	confname=$1; shift 1

	echo "${PIDS_DIR}/${confname}.pid"
}

function is_onconffile {
	local confname line

	confname=$1; shift 1
	line=$(head -1 "${CONF_DIR}/${confname}.conf" | grep "service=conffile")
	if [ -n "${line}" ]; then
		return 0
	else
		return 1
	fi
}

function is_dir_empty {
	local names path

	path=$1; shift 1
	if [ -d "${path}" ]; then
		names=$(ls "${path}" 2> /dev/null| head -1)
		if [ -z "${names}" ]; then
			return 0
		fi
	fi
	return 1
}

function is_running {
	local confname pgid

	confname=$1; shift 1

	if [ -e "${SERVICES_DIR}/${confname}" ]; then
		pgid=$(get_pid "${confname}")
		if [ "${pgid}" = "x" ]; then
			return 0
		fi
		if [ -n "${pgid}" ] && kill -0 "-${pgid}" 2> /dev/null; then
			return 0
		fi
	fi
	return 1
}

function list {
	local confname confnames

	confname=$1; shift 1

	confnames=$(get_confnames "${confname}")
	if [ -n "${confnames}" ]; then
		echo "${confnames}"
	fi
}

function make_required_dirs {
	for name in "${CONF_DIR}" "${PIDS_DIR}" "${SERVICES_DIR}"; do
		if [ ! -e "${name}" ]; then
			if ! mkdir -m 0755 -p "${name}"; then
				echoe "error: cannot create required directory (${name})"
				exit 1
			fi
		fi
	done
}

function status {
	local pgid

	echo -n "[${confname}] "
	if is_running "${confname}"; then
		echo "RUNNING"
		return 0
	else
		echo "NOT RUNNING"
		return 1
	fi
}

function restart {
	stop
	start
}

function start {
	local pgid

	# ensure required working dirs
	create_dirs "${confname}"

	#echo -n "starting server (${confname}) ... "
	echo -n "[${confname}] "
	if is_running "${confname}"; then
		echo "RUNNING"
		return 0
	fi

	# ensure override main:addr
	clean_servicefile "${confname}"
	if is_onconffile "${confname}"; then
		cp "${CONF_DIR}/${confname}.conf" "${SERVICES_DIR}/${confname}"
		echo "
[main]
addr=
" >> "${SERVICES_DIR}/${confname}"
		echo "x" > "${pidpath}"
	else
		ruspawn -f "${confpath}" -c "main:pgid=0" -c "main:addr=/+/${confname}"< /dev/null > /dev/null 2>&1 & pgid=$!
		echo "${pgid}" > "${pidpath}"
	fi

	for i in $(seq 20); do
		if is_running "${confname}"; then
			echo "STARTED"
			return 0
		fi
		sleep 0.1
	done

	echo "START FAILED"
	return 1
}

function stop {
	local pgid

	#echo -n "stopping server (${confname}) ... "
	echo -n "[${confname}] "
	if ! is_running "${confname}"; then
		echo "NOT RUNNING"
		clean_dirs "${confname}"
		return 1
	fi

	pgid=$(get_pid "${confname}")
	kill -TERM "-${pgid}" 2> /dev/null
	rm -f "${pidpath}" 2> /dev/null
	if ! is_running; then
		echo "STOPPED"
		clean_servicefile "${confname}"
		clean_dirs "${confname}"
		return 0
	else
		echo "STOP FAILED"
		return 1
	fi
}

function sync {
	if [ ! -e "${SOURCES_FILE}" ]; then
		echoe "error: cannot find sources file (${SOURCES_FILE})"
		exit 1
	fi

	fqhost=$(hostname -f 2>/dev/null)
	domain=$(hostname --domain 2>/dev/null)

	while read line; do
		if [ "${line:0:1}" = "#" -o "${line}" = "" ]; then
			continue
		fi

		name=${line%%:*}
		rest=${line#*:}
		typ=${rest%%:*}

		echo "syncing ${typ} (${name}) ..."
		case "${typ}" in
		dir)
			path=${rest#*:}
			path=$(russ_str_resolve "HOST=${fqhost}" "DOMAIN=${domain}" "${path}")

			if [ ! -d "${path}" ]; then
				echoe "warning: cannot find dir (${path})"
			else
				cp -r "${path}"/* "${CONF_DIR}"
			fi
			;;
		http|https)
			# EXPERIMENTAL
			names=${rest%%:*}
			url=${rest#*:}

			for name in ${names}; do
				url=$(russ_str_resolve "HOST=${fqhost}" "DOMAIN=${domain}" "NAME=${name}" "${url}")

				data=$(curl "${url}" 2>/dev/null)
				if [ $? -ne 0 ]; then
					echoe "warning: cannot pull from url (${url})"
				else
					dname=$(dirname "${name}")
					bname=$(basename "${name}")
					mkdir -p "${CONF_DIR}/${dname}"
					echo "${data}" > "${CONF_DIR}/${name}"
				fi
			done
			;;
		*)
			echoe "error: unknown sources type (${typ})"
			;;
		esac

	done < "${SOURCES_FILE}"
}

function print_usage {
	echo "\
usage: $PROGNAME clean|resync|sync
       $PROGNAME [-n] <confname> {start|stop|restart|status|list}
       $PROGNAME list|status
       $PROGNAME -h|--help|help

Manage system RUSS servers and configuration.

The file ruservice.sources contains directives for setting up the
configuration files in the ephemeral directory:
	${CONF_DIR}

The configuration directory is managed using:
clean	Clean configuration directory.
sync	Load configuration directory based on the ruservice.sources
	file.
resync	Call clean+sync.

Once the configuration directory is set up, servers may be managed
by start, stop, restart, status, and list.

The <confname> is one of:
* a configuration filename/path (without the .conf)
* a directory for all configurations under it
* \".\" for all
* server name (when -n is specified) matching all configurations
  with 'name=<name>' in the #russ header line."
}

if [ ! -e "${SOURCES_FILE}" ]; then
	# hand off to legacy (< v7) version
	echoe "info: calling ruservice-legacy"
	exec ruservice-legacy "$@"
fi

PROGNAME=$(basename $0)

make_required_dirs

if [ $# -eq 1 ]; then
	confname=""
	cmd=$1; shift 1

	case "${cmd}" in
	-h|--help|help)
		print_usage
		exit 0
		;;
	clean)
		clean_confdir
		;;
	list)
		$0 . list
		;;
	resync)
		clean_confdir
		sync
		;;
	status)
		$0 . status
		;;
	sync)
		sync
		;;
	*)
		echoe "error: bad/missing arguments"
		exit 1
		;;
	esac
elif [ $# -eq 2 ] || [ $# -eq 3 ]; then
	if [ "$1" = "-n" ]; then
		matchnames=1
		shift 1
	fi
	confname=$1; shift 1
	cmd=$1; shift 1

	if [ "${cmd}" = "list" ]; then
		list "${confname}"
		exit 0
	fi

	if [ "${matchnames}" = "1" ]; then
		confnames=$(get_confnamesbyname "${confname}")
	else
		confnames=$(get_confnames "${confname}")
	fi
	for confname in ${confnames}; do
		confpath="${CONF_DIR}/${confname}.conf"
		pidpath=$(get_pidpath "${confname}")

		if [ ! -r "${confpath}" ]; then
			echoe "error: cannot find configuration"
		else
			case "${cmd}" in
			status)
				status
				;;
			start)
				start
				;;
			stop)
				stop
				;;
			restart)
				restart
				;;
			*)
				echoe "error: bad/missing arguments"
				exit 1
				;;
			esac
		fi
	done
else
	echoe "error: bad/missing arguments"
	exit 1
fi
