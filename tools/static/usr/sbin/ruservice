#! /bin/bash
#
# ruservice

ETC_DIR=/etc/russ
RUN_DIR=/var/run/russ
CONF_DIR=${ETC_DIR}/conf
PIDS_DIR=${RUN_DIR}/pids
SERVICES_DIR="${RUN_DIR}/services"

function clean_servicefile {
	local confname

	confname=$1; shift 1

	rm -f "${SERVICES_DIR}/${confname}" 2> /dev/null
}

function create_dirs {
	for path in "${PIDS_DIR}" "${SERVICES_DIR}"; do
		if [ ! -d "${path}" ]; then
			mkdir -m 0755 -p "${path}"
			if [ $? -ne 0 ]; then
				echo "error: cannot create directory (${path})" 1>&2
				exit 1
			fi
		fi
	done
}

function get_confnames {
	local confname confnames filename filenames

	confname=$1; shift 1

	confnames=()
	if [ "${confname}" = "." ]; then
		filenames=$(cd "${CONF_DIR}"; \ls *.conf)
	else
		filenames=$(cd "${CONF_DIR}"; \ls "${confname}.conf" "${confname}".*.conf 2>/dev/null)
	fi
	for filename in ${filenames}; do
		confname="${filename%.conf}"
		if [ "${confname}" != "${filename}" ]; then
			confnames+=("${confname}")
		fi
	done
	echo "${confnames[*]}"
}

function get_pid {
	local confname pid pidpath

	confname=$1; shift 1

	pidpath=$(get_pidpath "${confname}")
	pid=$(cat "${pidpath}" 2> /dev/null)
	echo "${pid}"
}

function get_pidpath {
	local confname

	confname=$1; shift 1

	echo "${PIDS_DIR}/${confname}.pid"
}

function is_onconffile {
	local confname line

	confname=$1; shift 1
	line=$(head -1 "${CONF_DIR}/${confname}.conf" | grep "service=conffile")
	if [ -n "${line}" ]; then
		return 0
	else
		return 1
	fi
}

function is_running {
	local confname pgid

	confname=$1; shift 1

	if [ -e "${SERVICES_DIR}/${confname}" ]; then
		pgid=$(get_pid "${confname}")
		if [ "${pgid}" = "x" ]; then
			return 0
		fi
		if [ -n "${pgid}" ] && kill -0 "-${pgid}" 2> /dev/null; then
			return 0
		fi
	fi
	return 1
}

function list {
	local confname confnames

	confname=$1; shift 1

	confnames=$(get_confnames "${confname}")
	if [ -n "${confnames}" ]; then
		echo "${confnames}"
	fi
}

function status {
	local pgid

	echo -n "[${confname}] "
	if is_running "${confname}"; then
		echo "RUNNING"
		return 0
	else
		echo "NOT RUNNING"
		return 1
	fi
}

function restart {
	stop
	start
}

function start {
	local pgid

	# ensure required working dirs
	create_dirs

	#echo -n "starting server (${confname}) ... "
	echo -n "[${confname}] "
	if is_running "${confname}"; then
		echo "RUNNING"
		return 0
	fi

	# ensure override main:addr
	clean_servicefile "${confname}"
	if is_onconffile "${confname}"; then
		cp "${CONF_DIR}/${confname}.conf" "${SERVICES_DIR}/${confname}"
		echo "
[main]
addr=
" >> "${SERVICES_DIR}/${confname}"
		echo "x" > "${pidpath}"
	else
		ruspawn -f "${confpath}" -c "main:pgid=0" -c "main:addr=/+/${confname}"< /dev/null > /dev/null 2>&1 & pgid=$!
		echo "${pgid}" > "${pidpath}"
	fi

	for i in $(seq 20); do
		if is_running "${confname}"; then
			echo "STARTED"
			return 0
		fi
		sleep 0.1
	done

	echo "START FAILED"
	return 1
}

function stop {
	local pgid

	#echo -n "stopping server (${confname}) ... "
	echo -n "[${confname}] "
	if ! is_running "${confname}"; then
		echo "NOT RUNNING"
		return 1
	fi

	pgid=$(get_pid "${confname}")
	kill -TERM "-${pgid}" 2> /dev/null
	rm -f "${pidpath}" 2> /dev/null
	if ! is_running; then
		echo "STOPPED"
		clean_servicefile "${confname}"
		return 0
	else
		echo "STOP FAILED"
		return 1
	fi
}

function print_usage {
	echo "\
usage: $PROGNAME <confname> {start|stop|restart|status|list}
       $PROGNAME list|status
       $PROGNAME -h|--help|help

Manage system configured RUSS servers. Configurations must be in
	${CONF_DIR}
The server address will be set to the configuration name (and
override any main:addr setting in the original configuration).

Where:
<confname>	Configuration name (not including .conf). confname of
		\".\" means all configuration names."
}

PROGNAME=$(basename $0)

if [ $# -eq 1 ]; then
	confname=""
	cmd=$1; shift 1

	case "${cmd}" in
	-h|--help|help)
		print_usage
		exit 0
		;;
	list)
		$0 . list
		;;
	status)
		$0 . status
		;;
	*)
		echo "error: bad/missing arguments"
		exit 1
		;;
	esac
elif [ $# -eq 2 ]; then
	confname=$1; shift 1
	cmd=$1; shift 1

	if [ "${cmd}" = "list" ]; then
		list "${confname}"
		exit 0
	fi

	confnames=$(get_confnames "${confname}")
	for confname in ${confnames}; do
		confpath="${CONF_DIR}/${confname}.conf"
		pidpath=$(get_pidpath "${confname}")

		if [ ! -r "${confpath}" ]; then
			echo "error: cannot find configuration" 1>&2
		else
			case "${cmd}" in
			status)
				status
				;;
			start)
				start
				;;
			stop)
				stop
				;;
			restart)
				restart
				;;
			*)
				echo "error: bad/missing arguments"
				exit 1
				;;
			esac
		fi
	done
else
	echo "error: bad/missing arguments" 1>&2
	exit 1
fi
